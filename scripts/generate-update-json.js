#!/usr/bin/env node

/**
 * Generate update.json for Tauri updater from built artifacts.
 *
 * This script reads the signature files generated by `tauri build` with signing enabled
 * and creates an update.json manifest for the Tauri updater plugin.
 *
 * Supports both v1 format (.nsis.zip) and v2 format (.exe direct signing).
 *
 * Environment variables:
 * - TAG_NAME: The git tag name (e.g., "v0.2.0")
 * - GITHUB_REPOSITORY: The GitHub repository (e.g., "kbzowski/ntfier") - auto-set in GitHub Actions
 */

const fs = require("fs");
const path = require("path");

// Configuration
const REPO = process.env.GITHUB_REPOSITORY || "kbzowski/ntfier";
const TAG_NAME = process.env.TAG_NAME;

if (!TAG_NAME) {
	console.error("Error: TAG_NAME environment variable is required");
	process.exit(1);
}

// Extract version from tag (remove 'v' prefix if present)
const VERSION = TAG_NAME.replace(/^v/, "");

// Paths to Tauri build output
const BUNDLE_DIR = path.join(__dirname, "..", "src-tauri", "target", "release", "bundle");
const NSIS_DIR = path.join(BUNDLE_DIR, "nsis");

/**
 * Find files matching a pattern in a directory
 */
function findFiles(dir, pattern) {
	if (!fs.existsSync(dir)) {
		return [];
	}

	return fs
		.readdirSync(dir)
		.filter((file) => pattern.test(file))
		.map((file) => path.join(dir, file));
}

/**
 * Read signature from .sig file
 */
function readSignature(sigPath) {
	if (!fs.existsSync(sigPath)) {
		console.warn(`Warning: Signature file not found: ${sigPath}`);
		return null;
	}
	return fs.readFileSync(sigPath, "utf-8").trim();
}

/**
 * Determine platform from filename
 */
function getPlatformFromFilename(filename) {
	if (filename.includes("x64") || filename.includes("x86_64")) {
		return "windows-x86_64";
	} else if (filename.includes("x86") || filename.includes("i686")) {
		return "windows-i686";
	} else if (filename.includes("arm64") || filename.includes("aarch64")) {
		return "windows-aarch64";
	}
	return null;
}

/**
 * Main function to generate update.json
 */
function generateUpdateJson() {
	console.log(`Generating update.json for version ${VERSION}...`);
	console.log(`Looking for artifacts in: ${BUNDLE_DIR}`);

	const platforms = {};

	// Try v1 format first: .nsis.zip files
	const nsisZips = findFiles(NSIS_DIR, /\.nsis\.zip$/);

	if (nsisZips.length > 0) {
		console.log("Found v1 format artifacts (.nsis.zip)");
		for (const zipPath of nsisZips) {
			const zipName = path.basename(zipPath);
			const sigPath = `${zipPath}.sig`;
			const signature = readSignature(sigPath);

			if (!signature) {
				console.warn(`Skipping ${zipName}: no signature found`);
				continue;
			}

			const platform = getPlatformFromFilename(zipName);
			if (platform) {
				const downloadUrl = `https://github.com/${REPO}/releases/download/${TAG_NAME}/${zipName}`;
				platforms[platform] = {
					signature: signature,
					url: downloadUrl,
				};
				console.log(`Added ${platform}: ${zipName}`);
			}
		}
	}

	// Try v2 format: direct .exe files with .exe.sig
	if (Object.keys(platforms).length === 0) {
		console.log("Trying v2 format artifacts (.exe with .exe.sig)");
		const nsisExes = findFiles(NSIS_DIR, /-setup\.exe$/);

		for (const exePath of nsisExes) {
			const exeName = path.basename(exePath);
			const sigPath = `${exePath}.sig`;
			const signature = readSignature(sigPath);

			if (!signature) {
				console.warn(`Skipping ${exeName}: no signature found`);
				continue;
			}

			const platform = getPlatformFromFilename(exeName);
			if (platform) {
				const downloadUrl = `https://github.com/${REPO}/releases/download/${TAG_NAME}/${exeName}`;
				platforms[platform] = {
					signature: signature,
					url: downloadUrl,
				};
				console.log(`Added ${platform}: ${exeName}`);
			}
		}
	}

	if (Object.keys(platforms).length === 0) {
		console.error("Error: No signed artifacts found!");
		console.error("Make sure TAURI_SIGNING_PRIVATE_KEY is set and build completed successfully.");
		process.exit(1);
	}

	const updateJson = {
		version: VERSION,
		notes: `Release ${TAG_NAME}. See release notes on GitHub for details.`,
		pub_date: new Date().toISOString(),
		platforms: platforms,
	};

	// Write update.json to repository root (for upload to release)
	const outputPath = path.join(__dirname, "..", "update.json");
	fs.writeFileSync(outputPath, JSON.stringify(updateJson, null, 2));
	console.log(`\nGenerated: ${outputPath}`);
	console.log(JSON.stringify(updateJson, null, 2));

	return updateJson;
}

// Run
generateUpdateJson();
